　　まず、実装について説明する。
　最初にheadとtailをグローバルに宣言して0に初期化する。
　次に、sumをしている動作の前後でlockとunlockを実装する。
　lockでは、headに1加える動作をアトミックに行い、headに1加える前の
　値を返り値vとして受け取る。ここでvがtailに等しくなるまでループさせる。
　unlockでは、tailをインクリメントする。

　　この実装において、クリティカルセクションに入ろうとするプロセスはそれぞれ
　その時のheadの値を保持してheadに1加える動作をアトミックに行うことで、各
　プロセスが保持するheadの値は重複せず、また、0から2等と飛んだ値になることは
　ない。そのため、次にクリティカルセクションに入れるプロセスは保持しているheadの値が
　tailに等しい1つのプロセスだけであり、また、どのプロセスもクリティカルセクションに入れない
　ような状況は存在しない。そして、プロセスがクリティカルセクションを抜けたタイミングでtailが
　インクリメントされることでheadの番号が１つ大きいプロセスが次にクリティカルセクションに入れる
　ようになる。待ち状態のプロセスはhead番号を保持しており、その番号の小さい方から早くクリティカル
　セクションに入れるため、あるプロセスがずっと待機状態であるといった状況にはなりえない。